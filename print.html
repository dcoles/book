<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust on ESP Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A comprehensive guide on using the Rust programming language with Espressif SoCs and modules">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="overview/index.html"><strong aria-hidden="true">2.</strong> Ecosystem Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/using-the-standard-library.html"><strong aria-hidden="true">2.1.</strong> Using the Standard Library (std)</a></li><li class="chapter-item expanded "><a href="overview/bare-metal.html"><strong aria-hidden="true">2.2.</strong> Bare Metal (no_std)</a></li><li class="chapter-item expanded "><a href="overview/comparing-std-and-no_std.html"><strong aria-hidden="true">2.3.</strong> Comparing std and no_std</a></li></ol></li><li class="chapter-item expanded "><a href="dependencies/index.html"><strong aria-hidden="true">3.</strong> Required Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dependencies/installing-rust.html"><strong aria-hidden="true">3.1.</strong> Installing Rust</a></li><li class="chapter-item expanded "><a href="dependencies/build-tools.html"><strong aria-hidden="true">3.2.</strong> Build Tools</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Tooling</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/text-editors-and-ides.html"><strong aria-hidden="true">4.1.</strong> Text Editors and IDEs</a></li><li class="chapter-item expanded "><a href="tooling/espflash.html"><strong aria-hidden="true">4.2.</strong> espflash</a></li><li class="chapter-item expanded "><a href="tooling/espmonitor.html"><strong aria-hidden="true">4.3.</strong> espmonitor</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Debugging</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/debugging/probe-rs.html"><strong aria-hidden="true">4.4.1.</strong> probe-rs</a></li><li class="chapter-item expanded "><a href="tooling/debugging/openocd.html"><strong aria-hidden="true">4.4.2.</strong> OpenOCD</a></li><li class="chapter-item expanded "><a href="tooling/debugging/vscode-debugging.html"><strong aria-hidden="true">4.4.3.</strong> Debugging in Visual Studio Code</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Writing Your Application</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-your-application/generate-project-from-template.html"><strong aria-hidden="true">5.1.</strong> Generate Project from Template</a></li><li class="chapter-item expanded "><a href="writing-your-application/writing-std-applications.html"><strong aria-hidden="true">5.2.</strong> Writing std Applications</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Writing no_std Applications (TODO)</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="misc/glossary.html">Appendix A: Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust on ESP Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/esp-rs/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The goal of this book is to provide a comprehensive guide on using the <a href="https://www.rust-lang.org/">Rust programming language</a> with <a href="https://espressif.com/">Espressif</a> SoCs and modules.</p>
<p>Rust support for these devices is still in the early stages, but progress is being made rapidly. Because of this parts of this documentation may be out of date or change dramatically between readings.</p>
<p>For tools and libraries relating to Rust on ESP, please see the <a href="https://github.com/esp-rs/">esp-rs organization</a> on GitHub.</p>
<h2 id="status-of-this-book"><a class="header" href="#status-of-this-book">Status of This Book</a></h2>
<p>This book is currently a work in progress. A number of sections may be missing information or be missing altogether. If there is a specific topic you would like to see documented please <a href="https://github.com/esp-rs/book/issues/new">open an issue</a>.</p>
<p>If you feel you can contribute something to this book, we encourage you to <a href="https://github.com/esp-rs/book/pulls">create a pull request</a>!</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book is For</a></h2>
<p>This book assumes some experience with embedded development and the Rust programming language. Teaching these topics is outside the scope of this book.</p>
<p>If you are unfamiliar with either topic, please refer to the resources listed below to help you get started.</p>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<p>Some additional resources can be found below which may prove useful for those less experienced with embedded Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></td><td>If you are not familiar with Rust we recommend reading this book first.</td></tr>
<tr><td><a href="https://docs.rust-embedded.org/book/index.html">The Embedded Rust Book</a></td><td>Here you can find several other resources provided by Rust's Embedded Working Group.</td></tr>
<tr><td><a href="https://docs.rust-embedded.org/embedonomicon/">The Embedonomicon</a></td><td>The nitty gritty details when doing embedded programming in Rust.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ecosystem-overview"><a class="header" href="#ecosystem-overview">Ecosystem Overview</a></h1>
<p>There are two approaches for using Rust on Espressif chips:</p>
<ol>
<li><em>With</em> the full standard library available (<code>std</code>)</li>
<li><em>Without</em> the standard library available (<code>no_std</code>)</li>
</ol>
<p>Both approaches have their advantages and disadvantages, so you should make a decision based on your project's needs. This chapter contains an overview of the two approaches followed by a brief comparison between them.</p>
<ul>
<li><a href="overview/./using-the-standard-library.html">Using the Rust Standard Library (<code>std</code>)</a></li>
<li><a href="overview/./bare-metal.html">Bare Metal (<code>no_std</code>)</a></li>
<li><a href="overview/./comparing-std-and-no_std.html">Comparing <code>std</code> and <code>no_std</code></a></li>
</ul>
<p>The <a href="https://github.com/esp-rs/">esp-rs organization</a> on GitHub is home to a number of repositories related to running Rust on Espressif chips. Most of the required crates have their source code hosted here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-rust-standard-library-std"><a class="header" href="#using-the-rust-standard-library-std">Using the Rust Standard Library (<code>std</code>)</a></h1>
<p>Espressif provides a C-based development framework called <a href="https://github.com/espressif/esp-idf">esp-idf</a> which has support for all Espressif chips starting with the ESP32; note that this framework does <em>not</em> support the ESP8266.</p>
<p><code>esp-idf</code> in turn provides a <a href="https://sourceware.org/newlib/">newlib</a> environment with enough functionality to build the Rust standard library (<code>std</code>) on top of it. This is the approach that is being taken to enable <code>std</code> support on ESP devices.</p>
<h2 id="chip-support"><a class="header" href="#chip-support">Chip Support</a></h2>
<p>In order for applications targeting <code>std</code> to be built for ESP devices, two things are required:</p>
<ol>
<li>LLVM/Clang support</li>
<li>Support for the device in <code>esp-idf</code></li>
</ol>
<p>Refer to the table below to see if your chip is supported.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Chip</th><th style="text-align: center">Supported?</th></tr></thead><tbody>
<tr><td style="text-align: center">ESP32</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">ESP32-C2</td><td style="text-align: center"><em>planned</em></td></tr>
<tr><td style="text-align: center">ESP32-C3</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">ESP32-S2</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">ESP32-S3</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">ESP32-H2</td><td style="text-align: center"><em>planned</em></td></tr>
<tr><td style="text-align: center">ESP8266</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div>
<p>Since <code>esp-idf</code> does not have support for the ESP8266, we unfortunately are unable to use these libraries with it. See the <a href="overview/./bare-metal.html">Bare Metal</a> page for information on the <code>no_std</code> HAL for this chip.</p>
<h2 id="standard-library-features"><a class="header" href="#standard-library-features">Standard Library Features</a></h2>
<p>The supported <code>std</code> features are as follows:</p>
<ul>
<li>Threads</li>
<li>Mutexes and other synchronization primitives</li>
<li>Collections</li>
<li>Random number generation</li>
<li>Sockets</li>
</ul>
<p>In addition to the <code>std</code> features there is an <a href="https://github.com/esp-rs/embedded-svc">embedded-svc</a> implementation for <code>esp-idf</code>, <a href="https://github.com/esp-rs/esp-idf-svc">esp-idf-svc</a>, which adds extra support for services/modules not available in the standard library, including:</p>
<ul>
<li>Wi-Fi management</li>
<li>NVS (non-volatile storage)</li>
<li>Networking services like <code>httpd</code> and <code>ping</code></li>
</ul>
<p>In general, this approach should feel quite similar to developing for most normal PC environments.</p>
<h2 id="relevant-esp-rs-crates"><a class="header" href="#relevant-esp-rs-crates">Relevant <code>esp-rs</code> crates</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/esp-rs/esp-idf-hal">esp-rs/esp-idf-hal</a></td><td>An implementation of the <code>embedded-hal</code> and other traits using the <code>esp-idf</code> framework.</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-idf-svc">esp-rs/esp-idf-svc</a></td><td>An implementation of <a href="https://github.com/esp-rs/embedded-svc">embedded-svc</a> using <code>esp-idf</code> drivers.</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-idf-sys">esp-rs/esp-idf-sys</a></td><td>Rust bindings to the <code>esp-idf</code> development framework. Gives raw (<code>unsafe</code>) access to drivers, Wi-Fi and more.</td></tr>
<tr><td><a href="https://github.com/esp-rs/embedded-svc">esp-rs/embedded-svc</a></td><td>Abstraction traits for embedded services. (<code>WiFi</code>, <code>Network</code>, <code>Httpd</code>, <code>Logging</code>, etc.)</td></tr>
</tbody></table>
</div>
<p>The aforementioned crates have interdependencies, and this relationship can be seen below.</p>
<pre class="mermaid">graph TD;
    esp-idf-hal --&gt; esp-idf-sys &amp; embedded-svc
    esp-idf-svc --&gt; esp-idf-sys &amp; esp-idf-hal &amp; embedded-svc
</pre>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="i-updated-my-sdkconfigdefaults-file-but-it-doesnt-appear-to-have-had-any-effect"><a class="header" href="#i-updated-my-sdkconfigdefaults-file-but-it-doesnt-appear-to-have-had-any-effect">I updated my <code>sdkconfig.defaults</code> file but it doesn't appear to have had any effect</a></h3>
<p>You must clean your project and rebuild in order for changes in the <code>sdkconfig.defaults</code> to take effect:</p>
<pre><code class="language-shell ignore">$ cargo clean
$ cargo build
</code></pre>
<h3 id="the-documentation-for-the-crates-mentioned-on-this-page-is-out-of-date-or-missing"><a class="header" href="#the-documentation-for-the-crates-mentioned-on-this-page-is-out-of-date-or-missing">The documentation for the crates mentioned on this page is out of date or missing</a></h3>
<p>Due to the <a href="https://docs.rs/about/builds#hitting-resource-limits">resource limits</a> imposed by <a href="https://docs.rs">docs.rs</a>, internet access is blocked while building documentation and as such we are unable to build the documentation for <code>esp-idf-sys</code> or any crate depending on it.</p>
<p>Instead, we are building the documentation and hosting it ourselves on GitHub Pages:</p>
<ul>
<li><a href="https://esp-rs.github.io/esp-idf-hal/esp_idf_hal/"><code>esp-idf-hal</code> Documentation</a></li>
<li><a href="https://esp-rs.github.io/esp-idf-svc/esp_idf_svc/"><code>esp-idf-svc</code> Documentation</a></li>
<li><a href="https://esp-rs.github.io/esp-idf-sys/esp_idf_sys/"><code>esp-idf-sys</code> Documentation</a></li>
</ul>
<h3 id="error-a-stack-overflow-in-task-main-has-been-detected"><a class="header" href="#error-a-stack-overflow-in-task-main-has-been-detected">***ERROR*** A stack overflow in task main has been detected.</a></h3>
<p>If the second-stage bootloader reports this error, you likely need to increase the stack size for the main task. This can be accomplished by adding the following to the <code>sdkconfig.defaults</code> file:</p>
<pre><code class="language-ignore">CONFIG_ESP_MAIN_TASK_STACK_SIZE=7000
</code></pre>
<p>In this example, we are allocating 7kB for the main task's stack.</p>
<h3 id="how-can-i-completely-disable-the-watchdog-timers"><a class="header" href="#how-can-i-completely-disable-the-watchdog-timers">How can I completely disable the watchdog timer(s)?</a></h3>
<p>Add to your <code>sdkconfig.defaults</code> file:</p>
<pre><code class="language-ignore">CONFIG_INT_WDT=n
CONFIG_ESP_TASK_WDT=n
</code></pre>
<p>Recall that you must clean your project before rebuilding when modifying these configuration files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bare-metal-no_std"><a class="header" href="#bare-metal-no_std">Bare Metal (<code>no_std</code>)</a></h1>
<p>Using <code>no_std</code> may be more familiar to embedded Rust developers; it does not use <code>std</code> (the Rust standard library) but instead uses a subset, the <code>core</code> library. The <a href="https://docs.rust-embedded.org/">official Rust embedded book</a> has a <a href="https://docs.rust-embedded.org/book/intro/no-std.html">great section on this</a>.</p>
<p>It's important to note that in general a <code>no_std</code> crate can always compile in <code>std</code> environment but the inverse is not true. Therefore, when creating crates it's worth keeping in mind if it needs the standard library to function.</p>
<h2 id="hardware-abstraction-layers"><a class="header" href="#hardware-abstraction-layers">Hardware Abstraction Layers</a></h2>
<p>Previously, the primary focus of <code>no_std</code> development was the ESP32 and (to a lesser extent) the ESP8266, via <a href="https://github.com/esp-rs/esp32-hal">esp-rs/esp32-hal</a> and <a href="https://github.com/esp-rs/esp8266-hal">esp-rs/esp8266-hal</a>.</p>
<p>While <code>esp32-hal</code> and <code>esp8266-hal</code> have great support for a lot of the onboard peripherals, Wi-Fi and Bluetooth are <strong>not</strong> currently supported in a <code>no_std</code> enviroment. <a href="https://github.com/esp-rs/esp32-wifi">esp-rs/esp32-wifi</a> was created to explore getting it working, but it is not yet functional.</p>
<p>More recently, there has been a renewed effort to implement <code>no_std</code> support for the entire lineup of Espressif devices from the ESP32 and newer. These new HALs can be found in the <a href="https://github.com/esp-rs/esp-hal">esp-rs/esp-hal</a> repository.</p>
<h2 id="chip-support-1"><a class="header" href="#chip-support-1">Chip Support</a></h2>
<p>Chip support for <code>no_std</code> requires LLVM/Clang support just like for <code>std</code>. However, this has no dependency on <code>esp-idf</code>. In addition to compiler support, it's necessary to have peripheral access crates (PAC) and hardware abstraction layers (HAL) for your desired chip.</p>
<p>Refer to the table below to see if your chip is supported. Please note that the <code>no_std</code> HALs are still in the early phases of development, so not all peripherals have had drivers implemented.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Chip</th><th style="text-align: center">PAC</th><th style="text-align: center">HAL</th></tr></thead><tbody>
<tr><td style="text-align: center">ESP32</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">ESP32-C2</td><td style="text-align: center"><em>planned</em></td><td style="text-align: center"><em>planned</em></td></tr>
<tr><td style="text-align: center">ESP32-C3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">ESP32-S2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">ESP32-S3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">ESP32-H2</td><td style="text-align: center"><em>planned</em></td><td style="text-align: center"><em>planned</em></td></tr>
<tr><td style="text-align: center">ESP8266</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
</tbody></table>
</div>
<h2 id="relevant-esp-rs-crates-1"><a class="header" href="#relevant-esp-rs-crates-1">Relevant <code>esp-rs</code> Crates</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/esp-rs/esp-pacs">esp-rs/esp-pacs</a></td><td>A monorepo containing PACs for each supported device.</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-hal">esp-rs/esp-hal</a></td><td>An implementation of the <code>embedded-hal</code> traits and more for the ESP32, ESP32-C3, ESP32-S2, and ESP32-S3.</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp8266-hal">esp-rs/esp8266-hal</a></td><td>An implementation of the <code>embedded-hal</code> traits and more for the ESP8266.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="comparing-std-and-no_std"><a class="header" href="#comparing-std-and-no_std">Comparing <code>std</code> and <code>no_std</code></a></h1>
<p>There are a number of factors which must be considered when choosing between <code>std</code> (<a href="https://github.com/esp-rs/esp-idf-hal">esp-idf-hal</a>) and <code>no_std</code> (eg. <a href="https://github.com/esp-rs/esp32-hal">esp32-hal</a>). As stated previously, each approach has its own unique set of advantages and disadvantages. While we can't decide for you, this section will hopefully allow you to make an educated decision.</p>
<p>At present, there are unfortunately certain technical restrictions which may dictate your choice; we hope to have these issues resolved soon. Currently you <em>must</em> use the <code>std</code> approach if you require any of the following:</p>
<ul>
<li>Use of Wi-Fi or Bluetooth</li>
<li>The ability to target any chip other than the ESP32 or the ESP8266</li>
</ul>
<h2 id="application-runtimes"><a class="header" href="#application-runtimes">Application Runtimes</a></h2>
<p>In the case of applications (as opposed to libraries) the standard library provides a runtime which handles setting up stack overflow protection, spawning the main thread before an application's <code>main</code> function is invoked, and handling of command-line arguments.</p>
<p>Applications targeting <code>no_std</code> will be responsible for initializing their own runtimes instead. Runtime initialization is generally handled by an external dependency, in our case the <a href="https://github.com/rust-embedded/riscv-rt">riscv-rt</a> and <a href="https://github.com/esp-rs/xtensa-lx-rt">xtensa-lx-rt</a> libraries. You can refer to their READMEs and documentation for more information.</p>
<p>One advantage of not including the default runtime is that you're able to write applications at a lower level. This is possible because the applications will have been linked against the <code>core</code> crate instead of <code>std</code>, which makes no assumptions about the system it is running on. As such, it's possible to write applications like bootloaders, firmware, or even operating system kernels using the <code>no_std</code> approach.</p>
<h2 id="no_main"><a class="header" href="#no_main"><code>#![no_main]</code></a></h2>
<p>Another interesting property of <code>no_std</code> applications is that we cannot use Rust's default <code>main</code> function as our entry point. It makes certain assumptions which are not neccessarily valid in an embedded context (for example, it expects that command-line arguments exist).</p>
<p>Because of this, you will often see the <code>#![no_main]</code> attribute used to instruct the Rust compiler not to use the default entry point. Runtime crates will provide an <code>#[entry]</code> attribute which can be used to mark a diverging function as the application's entry point instead. For example a minimal application might look something like this:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use riscv_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {}
}
</code></pre>
<h2 id="panic-handlers"><a class="header" href="#panic-handlers">Panic Handlers</a></h2>
<p>In addition to specifying the application's entry point, for <code>no_std</code> we must also define a panic handler. The default panic behaviour relies on <code>std</code>, as it prints to standard output.</p>
<p>You are able to define a panic handler manually using the <code>#[panic_handler]</code> attribute. Note that this function's signature <em>must</em> match the example below.</p>
<pre><code class="language-rust ignore">#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    // Your implementation goes here!
}
</code></pre>
<p>Alternatively, there are a number of external dependencies which define various panic handlers for us. Some possible choices are <a href="https://github.com/korken89/panic-halt">panic-halt</a>, <a href="https://github.com/rust-embedded/cortex-m/tree/master/panic-semihosting">panic-semihosting</a>, or <a href="https://github.com/japaric/panic-never">panic-never</a>.</p>
<p>These can be used simply by installing the relevant dependency, and then importing the crate:</p>
<pre><code class="language-rust ignore">#![no_std]

use panic_halt as _;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="required-dependencies"><a class="header" href="#required-dependencies">Required Dependencies</a></h1>
<p>With an understanding of the ecosystem surrounding Rust on Espressif chips, we're able to move on to actual development. If you are not aware of the two possible development approaches, or do not understand the differences between writing <code>std</code> and <code>no_std</code> applications, please first read the <a href="dependencies/../overview/index.html">Ecosystem Overview</a> chapter.</p>
<p>In this chapter we will cover the installation of the correct Rust compiler and toolchain as well as creating applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h1>
<p>In order to develop for ESP devices using Rust you must first install the Rust compiler along with the appropriate toolchain and target(s). Depending on your device it may be one of two architectures, each requiring different setup.</p>
<p>If you have not yet installed Rust on your system, you can do so easily using <a href="https://rustup.rs/">rustup</a>. For <em>macOS</em> and <em>Linux</em> it can be installed by runing the following command:</p>
<pre><code class="language-bash">$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>For installation on Windows or alternative installation methods, please refer to the instructions on the <a href="https://rustup.rs/">rustup</a> website.</p>
<p>With Rust installed we next need to ensure that the <code>nightly</code> toolchain is installed and set as the default:</p>
<pre><code class="language-bash">$ rustup toolchain install nightly
$ rustup default nightly
</code></pre>
<p>You can read more about toolchains in the <a href="https://rust-lang.github.io/rustup/concepts/toolchains.html">rustup book</a>.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="git"><a class="header" href="#git">git</a></h3>
<p><code>git</code> must be installed on your system in order to clone repositories. This should be available via your system's package manager, or for Windows users <a href="https://gitforwindows.org/">Git for Windows</a> can be used.</p>
<h3 id="visual-studio-build-tools"><a class="header" href="#visual-studio-build-tools">Visual Studio Build Tools</a></h3>
<p>If you are running Windows as your host operating system, you must install the Visual Studio Build Tools, which can be downloaded from the <a href="https://visualstudio.microsoft.com/downloads/">Microsoft website</a>.</p>
<h3 id="xtensa-toolchain"><a class="header" href="#xtensa-toolchain">Xtensa Toolchain</a></h3>
<p>If you are developing for an Xtensa chip (<em>ESP32</em>, <em>ESP32-S2</em>, <em>ESP32-S3</em>) you must also install the appropriate Xtensa toolchain. Pre-built toolchains can be downloaded from the <a href="https://github.com/espressif/crosstool-NG">crosstool-NG</a> repository for the most common operating systems and architectures.</p>
<p>Ensure that you have downloaded the required toolchain and added its directory to your <code>PATH</code> environment variable prior to building your application.</p>
<h2 id="risc-v-esp32-c3"><a class="header" href="#risc-v-esp32-c3">RISC-V (ESP32-C3)</a></h2>
<p>The <code>RISC-V</code> architecture has support in the mainline Rust compiler so setup is relatively simple, all we must do is add the appropriate compilation target.</p>
<p>There are two suitable targets for this chip:</p>
<ul>
<li>For bare-metal (<code>no_std</code>) applications, use <code>riscv32imc-unknown-none-elf</code></li>
<li>For applications which require <code>std</code>, use <code>riscv32imc-esp-espidf</code></li>
</ul>
<p>The bare-metal target can be installed by running:</p>
<pre><code class="language-bash">$ rustup target add riscv32imc-unknown-none-elf
</code></pre>
<p>The standard library target (<code>riscv32imc-esp-espidf</code>) is currently Tier 3, and does not have prebuilt objects distributed through <code>rustup</code>, therefore the <code>-Z build-std</code> unstable cargo feature is required within your project. See an example usage in <a href="https://github.com/ivmarkov/rust-esp32-std-mini/blob/5fe3a5d75b16c6cee63e4c36b87f936744151494/.cargo/config.toml#L25-L26">rust-esp32-std-mini</a>.</p>
<p>At this point you are ready to build applications for the ESP32-C3.</p>
<h2 id="xtensa-esp32-esp32-s2-esp32-s3"><a class="header" href="#xtensa-esp32-esp32-s2-esp32-s3">Xtensa (ESP32, ESP32-S2, ESP32-S3)</a></h2>
<p>Because there is no <code>Xtensa</code> support in the mainline Rust compiler you must use the <a href="https://github.com/esp-rs/rust">esp-rs/rust</a> fork instead. There are a few options available for installing this compiler fork.</p>
<p>The forked compiler can coexist with the standard Rust compiler, so it is possible to have both installed on your system. The forked compiler is invoked when using the <code>esp</code> channel instead of the defaults, <code>stable</code> or <code>nightly</code>.</p>
<h3 id="using-a-pre-built-release"><a class="header" href="#using-a-pre-built-release">Using a Pre-Built Release</a></h3>
<p>Pre-built releases are available for a number of platforms on GitHub under the <a href="https://github.com/esp-rs/rust-build">esp-rs/rust-build</a> repository. The following operating systems and architectures are currently supported:</p>
<ul>
<li>macOS (<code>x86_64</code>, <code>aarch64</code>)</li>
<li>Windows (<code>x86_64</code>)</li>
<li>Linux (<code>x86_64</code>)</li>
</ul>
<p>The aforementioned repository also contains Bash and PowerShell scripts to automate the installation process.</p>
<h4 id="macos-and-linux"><a class="header" href="#macos-and-linux">macOS and Linux</a></h4>
<pre><code class="language-bash">$ curl -LO https://raw.githubusercontent.com/esp-rs/rust-build/main/install-rust-toolchain.sh
$ chmod +x install-rust-toolchain.sh
$ ./install-rust-toolchain.sh
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p>With GUI installer: <a href="https://github.com/espressif/idf-installer/releases">https://github.com/espressif/idf-installer/releases</a></p>
<p>With PowerShell:</p>
<pre><code class="language-powershell">PS&gt; Invoke-WebRequest https://raw.githubusercontent.com/esp-rs/rust-build/main/Install-RustToolchain.ps1 -OutFile Install-RustToolchain.ps1
PS&gt; ./Install-RustToolchain.ps1
</code></pre>
<p>To confirm the <code>esp</code> toolchain has been installed:</p>
<pre><code class="language-bash">$ rustup toolchain list
stable-x86_64-apple-darwin
nightly-x86_64-apple-darwin (default)
esp
</code></pre>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building From Source</a></h3>
<p>You can also build the Rust compiler with <code>Xtensa</code> support from source. This process is computationally expensive and can take one or more hours to complete depending on your system. It is recommended that you have <em>at least</em> 6GB of RAM and 25GB+ of available storage space.</p>
<p>To check out the repository and build the compiler:</p>
<pre><code class="language-bash">$ git clone https://github.com/esp-rs/rust
$ cd rust
$ ./configure --experimental-targets=Xtensa
$ ./x.py build --stage 2
</code></pre>
<p>Note that you should <em>not</em> rename the <code>rust</code> directory to avoid issues while building.</p>
<p>Once the build has completed, you can link the toolchain using rustup (your architecture/operating system may be different):</p>
<pre><code class="language-bash">$ rustup toolchain link esp $PWD/build/x86_64-apple-darwin/stage2
</code></pre>
<p>Once the compiler fork has been installed using one of the above methods, to confirm the <code>esp</code> toolchain has been installed:</p>
<pre><code class="language-bash">$ rustup toolchain list
stable-x86_64-apple-darwin
nightly-x86_64-apple-darwin (default)
esp
</code></pre>
<p>To view the installed <code>Xtensa</code> targets:</p>
<pre><code class="language-bash">$ rustc +esp --print target-list | grep xtensa
xtensa-esp32-espidf
xtensa-esp32-none-elf
xtensa-esp32s2-espidf
xtensa-esp32s2-none-elf
xtensa-esp8266-none-elf
xtensa-none-elf
</code></pre>
<h3 id="using-containers"><a class="header" href="#using-containers">Using Containers</a></h3>
<p>As an alternative to installing the compiler fork to your local system directly, it's also possible to run it inside of a container.</p>
<p>A number of container runtimes are available, and which should be used depends on your operating system. Some of the popular options are:</p>
<ul>
<li><a href="https://www.docker.com/">Docker</a> (non-commerial use only without a license)</li>
<li><a href="https://podman.io/">Podman</a></li>
<li><a href="https://github.com/lima-vm/lima">Lima</a></li>
</ul>
<p>Espressif provides the <a href="https://hub.docker.com/r/espressif/idf-rust">idf-rust</a> container image which contains <a href="https://github.com/espressif/esp-idf">esp-idf</a> and the pre-built Rust compiler fork.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-tools"><a class="header" href="#build-tools">Build Tools</a></h1>
<h2 id="ldproxy"><a class="header" href="#ldproxy">ldproxy</a></h2>
<p>When building applications using the Rust standard library, <code>std</code>, the build tool <code>ldproxy</code> is required and must be installed first; this tool can be found in the <a href="https://github.com/esp-rs/embuild">embuild repository</a>. This tool is <em>not</em> required for <code>no_std</code> applications.</p>
<p><code>ldproxy</code> is a simple tool to forward linker arguments given to <code>ldproxy</code> to the actual linker executable.</p>
<p>To install:</p>
<pre><code class="language-bash">$ cargo install ldproxy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-editors-and-ides"><a class="header" href="#text-editors-and-ides">Text Editors and IDEs</a></h1>
<p>While an often contentious subject, using the right development environment can make a significant impact on your productivity with a given programming language. Below can be found a curated list of what we feel are the best options.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>One of the more common development environents is Microsoft's <a href="https://code.visualstudio.com/">Visual Studio Code</a> text editor along with the <a href="https://rust-analyzer.github.io/">Rust Analyzer</a> extension.</p>
<p>Visual Studio Code is an open-source and cross-platform graphical text editor with a rich ecosystem of extensions. The Rust Analyzer extension provides an implementation of the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> for Rust, and additionally includes features like autocompletion, go to definition, and more.</p>
<p>Visual Studio Code can be installed via most popular package managers, and installers are available on the official website. The Rust Analyzer extension can be installed in Visual Studo Code via the built-in extension manager.</p>
<h3 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and Tricks</a></h3>
<p>If you are developing for a target which does not have <code>std</code> support Rust Analyzer can behave strangely, often reporting various errors. This can be resolved by creating a <code>.vscode/settings.json</code> file in your project and populating it with the following:</p>
<pre><code class="language-json">{
  &quot;rust-analyzer.checkOnSave.allTargets&quot;: false
}
</code></pre>
<p>If you are using a custom toolchain, as you would with Xtensa targets, you can provide some hints to <code>cargo</code> via the <code>rust-toolchain.toml</code> file to improve the user experience:</p>
<pre><code class="language-toml">[toolchain]
channel = &quot;esp&quot;
components = [&quot;rustfmt&quot;, &quot;rustc-dev&quot;]
targets = [&quot;xtensa-esp32-none-elf&quot;]
</code></pre>
<h2 id="clion"><a class="header" href="#clion">CLion</a></h2>
<p><a href="https://www.jetbrains.com/clion/">CLion</a> is a cross-platform IDE for C and C++ from <a href="https://www.jetbrains.com/">JetBrains</a>.</p>
<h2 id="intellij"><a class="header" href="#intellij">IntelliJ</a></h2>
<h2 id="vim"><a class="header" href="#vim">vim</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="espflash"><a class="header" href="#espflash">espflash</a></h1>
<p>A serial flasher utility for ESP devices. Supports flashing <em>ESP32</em>, <em>ESP32-C3</em>, <em>ESP32-S2</em>, and <em>ESP8266</em>.</p>
<p>The <a href="https://github.com/esp-rs/espflash">esp-rs/espflash</a> repository contains two crates, <code>cargo-espflash</code> and <code>espflash</code>. You can find more information on both of these in their respective sections below.</p>
<h2 id="cargo-espflash"><a class="header" href="#cargo-espflash">cargo-espflash</a></h2>
<p>Provides a subcommand for <code>cargo</code> which handles cross-compilation and flashing. Note that this requires the unstable <code>build-std</code> cargo feature; for more information on this please refer to <a href="https://doc.rust-lang.org/cargo/reference/unstable.html#build-std">the cargo documentation</a>.</p>
<p>To install:</p>
<pre><code class="language-bash">$ cargo install cargo-espflash
</code></pre>
<p>This command must be run within a Cargo project, ie.) a directory containing a <code>Cargo.toml</code> file. For example, to build an example named 'blinky' in <code>release</code> mode, flash the resulting binary to a device, and then subsequently start a serial monitor:</p>
<pre><code class="language-bash">$ cargo espflash --example=blinky --release --monitor
</code></pre>
<p>For more information please see to the <a href="https://github.com/esp-rs/espflash/blob/master/cargo-espflash/README.md">cargo-espflash README</a>.</p>
<h2 id="espflash-1"><a class="header" href="#espflash-1">espflash</a></h2>
<p>Provides a standalone command-line application which flashes an ELF file to a device.</p>
<p>To install:</p>
<pre><code class="language-bash">$ cargo install espflash
</code></pre>
<p>Assuming you have built an ELF binary by other means already, <code>espflash</code> can be used to download it to your device. For example, if you have built the <code>getting-started/blinky</code> example from <a href="https://github.com/espressif/esp-idf">esp-idf</a> using <code>idf.py</code> you might run something like:</p>
<pre><code class="language-bash">$ espflash build/blinky
</code></pre>
<p>For more information please see to the <a href="https://github.com/esp-rs/espflash/blob/master/espflash/README.md">espflash README</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="espmonitor"><a class="header" href="#espmonitor">espmonitor</a></h1>
<p>The <a href="https://github.com/esp-rs/espmonitor">esp-rs/espmonitor</a> repository contains two crates, <code>cargo-espmonitor</code> and <code>espmonitor</code>.</p>
<h2 id="cargo-espmonitor"><a class="header" href="#cargo-espmonitor">cargo-espmonitor</a></h2>
<pre><code class="language-bash">$ cargo install cargo-espmonitor
</code></pre>
<h2 id="espmonitor-1"><a class="header" href="#espmonitor-1">espmonitor</a></h2>
<pre><code class="language-bash">$ cargo install espmonitor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="probe-rs"><a class="header" href="#probe-rs">probe-rs</a></h1>
<p>The probe-rs project is a set of tools to interact with embedded MCU's using various debug probes. It is similar to openOCD, PyOCD, Segger tools etc. There is support for ARM &amp; RISCV architectures along with a collection of tools, including but not limited to:</p>
<ul>
<li>Debugger
<ul>
<li>GDB support.</li>
<li>CLI for interactive debugging.</li>
<li>VSCode extension.</li>
</ul>
</li>
<li>RTT (Real Time Transfer)
<ul>
<li>Similar to app_trace component of IDF.</li>
</ul>
</li>
<li>Flashing algorithms</li>
</ul>
<p>More info about probe-rs &amp; how to set up a project, can be found on the <a href="https://probe.rs/">probe.rs</a> website.</p>
<h2 id="usb-jtag-serial-peripheral-for-esp32-c3"><a class="header" href="#usb-jtag-serial-peripheral-for-esp32-c3"><code>USB-JTAG-SERIAL</code> peripheral for ESP32-C3</a></h2>
<p>Starting from <code>probe-rs</code> v0.12, it is possible to flash and debug the ESP32-C3 with the builtin <code>USB-JTAG-SERIAL</code> peripheral, no need for any external hardware debugger. More info on configuring the interface can be found in the <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-guides/jtag-debugging/configure-builtin-jtag.html">official documentation</a>.</p>
<h2 id="support-for-espressif-chips"><a class="header" href="#support-for-espressif-chips">Support for Espressif chips</a></h2>
<p><code>probe-rs</code> currently only supports ARM &amp; RISCV, therefore this limits the number of Espressif chips that can be used at the moment.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Chip</th><th style="text-align: center">Flashing</th><th style="text-align: center">Debugging</th></tr></thead><tbody>
<tr><td style="text-align: center">ESP32-C3</td><td style="text-align: center">✅</td><td style="text-align: center">⚠️</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: <em>items marked with ⚠️ are currently work in progress, usable but expect bugs.</em></p>
<h2 id="permissions---linux"><a class="header" href="#permissions---linux">Permissions - Linux</a></h2>
<p>On linux you may run into permission issues trying to interact with Espressif probes. Installing the following <code>udev</code> rules and reloading should fix that issue.</p>
<pre><code class="language-udev"># Espressif dev kit FTDI
ATTRS{idVendor}==&quot;0403&quot;, ATTRS{idProduct}==&quot;6010&quot;, MODE=&quot;660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;

# Espressif USB JTAG/serial debug unit
ATTRS{idVendor}==&quot;303a&quot;, ATTRS{idProduct}==&quot;1001&quot;, MODE=&quot;660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;

# Espressif USB Bridge
ATTRS{idVendor}==&quot;303a&quot;, ATTRS{idProduct}==&quot;1002&quot;, MODE=&quot;660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;
</code></pre>
<!-- TODO: when probe-rs can actually debug at least a C3 with decent back traces etc, add a section here with an example config: see https://github.com/probe-rs/probe-rs/issues/877 --><div style="break-before: page; page-break-before: always;"></div><h1 id="openocd"><a class="header" href="#openocd">OpenOCD</a></h1>
<p>Similar to <a href="tooling/debugging/./probe-rs.html">probe-rs</a>, OpenOCD does not have support for the Xtensa architecture. However, Espressif does maintain a fork of OpenOCD under <a href="https://github.com/espressif/openocd-esp32">espressif/openocd-esp32</a> which has support for Espressif's chips.</p>
<p>Instructions on how to install <code>openocd-esp32</code> for your platform can be found in <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-guides/jtag-debugging/index.html#setup-of-openocd">the Espressif documentation</a>.</p>
<h2 id="setup-for-espressif-chips"><a class="header" href="#setup-for-espressif-chips">Setup for Espressif chips</a></h2>
<!-- how to choose interface & chip -->
<p>Once installed, it's as simple as running <code>openocd</code> with the correct scripts. For chips with the builtin USB JTAG, there is normally a config that will work out of the box, for example on the ESP32-C3:</p>
<pre><code class="language-ignore">openocd -f board/esp32c3-builtin.cfg
</code></pre>
<p>For other configurations it may require specifying the chip and the interface separately, for example ESP32 with a J-Link:</p>
<pre><code class="language-ignore">openocd -f interface/jlink.cfg -f target/esp32.cfg
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-in-visual-studio-code"><a class="header" href="#debugging-in-visual-studio-code">Debugging in Visual Studio Code</a></h1>
<p>There is also a possibility to debug with graphical output directly in Visual Studio Code.</p>
<h1 id="esp32"><a class="header" href="#esp32">ESP32</a></h1>
<h2 id="hardware-setup"><a class="header" href="#hardware-setup">Hardware Setup</a></h2>
<p>ESP32 doesn't have a built-in JTAG interface so you have to connect an external JTAG adapter with the ESP32 board, for example <a href="https://docs.espressif.com/projects/espressif-esp-iot-solution/en/latest/hw-reference/ESP-Prog_guide.html">ESP-Prog</a> can be used.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ESP32 Pin</th><th style="text-align: center">JTAG Signal</th></tr></thead><tbody>
<tr><td style="text-align: center">MTDO/GPIO15</td><td style="text-align: center">TDO</td></tr>
<tr><td style="text-align: center">MTDI/GPIO12</td><td style="text-align: center">TDI</td></tr>
<tr><td style="text-align: center">MTCK/GPIO13</td><td style="text-align: center">TCK</td></tr>
<tr><td style="text-align: center">MTMS/GPIO14</td><td style="text-align: center">TMS</td></tr>
<tr><td style="text-align: center">3V3</td><td style="text-align: center">VJTAG</td></tr>
<tr><td style="text-align: center">GND</td><td style="text-align: center">GND</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: On Windows <code>USB Serial Converter A 0403 6010 00</code> driver should be WinUSB.</p>
<h2 id="set-up-vscode"><a class="header" href="#set-up-vscode">Set up VSCode</a></h2>
<ol>
<li>Install <a href="https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug">Cortex-Debug</a> extension for VScode.</li>
<li>Create the <code>.vscode/launch.json</code> file in the project tree you want to debug. <a href="https://github.com/esp-rs/esp32-hal/blob/master/.vscode/launch.json">This</a> can be used as a template file.</li>
<li>Update <strong>executable</strong>, <strong>svdFile</strong>, <strong>serverpath</strong> paths and <strong>toolchainPrefix</strong> field.</li>
</ol>
<pre><code class="language-jsonc">    {
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
            {
                // more info at: https://github.com/Marus/cortex-debug/blob/master/package.json
                &quot;name&quot;: &quot;Attach&quot;,
                &quot;type&quot;: &quot;cortex-debug&quot;,
                &quot;request&quot;: &quot;attach&quot;, // attach instead of launch, because otherwise flash write is attempted, but fails
                &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
                &quot;executable&quot;: &quot;target/xtensa-esp32-none-elf/debug/.....&quot;,
                &quot;servertype&quot;: &quot;openocd&quot;,
                &quot;interface&quot;: &quot;jtag&quot;,
                &quot;svdFile&quot;: &quot;../../esp-pacs/esp32/svd/esp32.svd&quot;,
                &quot;toolchainPrefix&quot;: &quot;xtensa-esp32-elf&quot;,
                &quot;openOCDPreConfigLaunchCommands&quot;: [
                    &quot;set ESP_RTOS none&quot;
                ],
                &quot;serverpath&quot;: &quot;C:/Espressif/tools/openocd-esp32/v0.11.0-esp32-20220411/openocd-esp32/bin/openocd.exe&quot;,
                &quot;configFiles&quot;: [
                    &quot;board/esp32-wrover-kit-3.3v.cfg&quot;
                ],
                &quot;overrideAttachCommands&quot;: [
                    &quot;set remote hardware-watchpoint-limit 2&quot;,
                    &quot;mon halt&quot;,
                    &quot;flushregs&quot;
                ],
                &quot;overrideRestartCommands&quot;: [
                    &quot;mon reset halt&quot;,
                    &quot;flushregs&quot;,
                    &quot;c&quot;,
                ]
            },
        ]
    }
</code></pre>
<h1 id="esp32-c3"><a class="header" href="#esp32-c3">ESP32-C3</a></h1>
<p>Older versions with <strong>revision &lt; 3</strong> <strong>doesn't</strong> have built-in JTAG interface.</p>
<p>ESP32-C3 with <strong>revision 3</strong> <strong>does</strong> have a built-in JTAG interface and you don't have to connect an external device to be able to debug. To get the chip revision, run the <code>cargo espflash board-info</code> command.</p>
<h2 id="hardware-setup-1"><a class="header" href="#hardware-setup-1">Hardware Setup</a></h2>
<p>If your ESP32-C3's revision is lesser than 3, follow these instructions, if you have revision 3 you can jump to the <strong>Set up VSCode</strong> step.</p>
<p>ESP32-C3 <strong>revision 1</strong> and <strong>revision 2</strong> don't have a built-in JTAG interface so you have to connect an external JTAG adapter with the ESP32-C3 board, for example <a href="https://docs.espressif.com/projects/espressif-esp-iot-solution/en/latest/hw-reference/ESP-Prog_guide.html">ESP-Prog</a> can be used.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ESP32-C3 Pin</th><th style="text-align: center">JTAG Signal</th></tr></thead><tbody>
<tr><td style="text-align: center">MTDO/GPIO7</td><td style="text-align: center">TDO</td></tr>
<tr><td style="text-align: center">MTDI/GPIO5</td><td style="text-align: center">TDI</td></tr>
<tr><td style="text-align: center">MTCK/GPIO6</td><td style="text-align: center">TCK</td></tr>
<tr><td style="text-align: center">MTMS/GPIO4</td><td style="text-align: center">TMS</td></tr>
<tr><td style="text-align: center">3V3</td><td style="text-align: center">VJTAG</td></tr>
<tr><td style="text-align: center">GND</td><td style="text-align: center">GND</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: On Windows <code>USB Serial Converter A 0403 6010 00</code> driver should be WinUSB.</p>
<h2 id="set-up-vscode-1"><a class="header" href="#set-up-vscode-1">Set up VSCode</a></h2>
<ol>
<li>Install <a href="https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug">Cortex-Debug</a> extension for VScode.</li>
<li>Create the <code>.vscode/launch.json</code> file in the project tree you want to debug. <a href="https://github.com/esp-rs/esp32-hal/blob/master/.vscode/launch.json">This</a> can be used as a template file.</li>
<li>Update <strong>executable</strong>, <strong>svdFile</strong>, <strong>serverpath</strong> paths and <strong>toolchainPrefix</strong> field.</li>
</ol>
<pre><code class="language-jsonc">    {
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
            {
                // more info at: https://github.com/Marus/cortex-debug/blob/master/package.json
                &quot;name&quot;: &quot;Attach&quot;,
                &quot;type&quot;: &quot;cortex-debug&quot;,
                &quot;request&quot;: &quot;attach&quot;, // attach instead of launch, because otherwise flash write is attempted, but fails
                &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
                &quot;executable&quot;: &quot;target/riscv32imc-unknown-none-elf/debug/examples/usb_serial_jtag&quot;, //
                &quot;servertype&quot;: &quot;openocd&quot;,
                &quot;interface&quot;: &quot;jtag&quot;,
                &quot;svdFile&quot;: &quot;../../esp-pacs/esp32c3/svd/esp32c3.svd&quot;,
                &quot;toolchainPrefix&quot;: &quot;riscv32-esp-elf&quot;,
                &quot;openOCDPreConfigLaunchCommands&quot;: [
                    &quot;set ESP_RTOS none&quot;
                ],
                &quot;serverpath&quot;: &quot;C:/Espressif/tools/openocd-esp32/v0.11.0-esp32-20220411/openocd-esp32/bin/openocd.exe&quot;,
                &quot;configFiles&quot;: [
                    &quot;board/esp32c3-builtin.cfg&quot;
                ],
                &quot;overrideAttachCommands&quot;: [
                    &quot;set remote hardware-watchpoint-limit 2&quot;,
                    &quot;mon halt&quot;,
                    &quot;flushregs&quot;
                ],
                &quot;overrideRestartCommands&quot;: [
                    &quot;mon reset halt&quot;,
                    &quot;flushregs&quot;,
                    &quot;c&quot;,
                ]
            },
        ]
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-applications"><a class="header" href="#creating-applications">Creating Applications</a></h1>
<p>With the appropriate Rust compiler and toolchain installed, you're now ready to create an application. As outlined below, there are essentially two ways to do this: generating from a template or starting from scratch using only <code>cargo</code>.</p>
<h2 id="using-cargo-generate"><a class="header" href="#using-cargo-generate">Using <code>cargo-generate</code></a></h2>
<p>The <a href="https://github.com/cargo-generate/cargo-generate">cargo-generate</a> subcommand allows you to create a new project based on some existing template. In our case <a href="https://github.com/esp-rs/esp-idf-template">esp-idf-template</a> or <a href="https://github.com/esp-rs/esp-template">esp-template</a> can be used to generate an application with all the required configuration and dependencies.</p>
<p><code>cargo generate</code> can be installed by running:</p>
<pre><code class="language-shell">$ cargo install cargo-generate
</code></pre>
<p>When the <code>cargo generate</code> subcommand is invoked, you will be prompted to answer a number of questions regarding the target of your application. Upon completion of this process you will have a buildable project with all the correct configuration.</p>
<p>The generated application can be built as normal using the appropriate toolchain and target simply by running <code>cargo build</code> when using either template.</p>
<h3 id="esp-idf-template"><a class="header" href="#esp-idf-template">esp-idf-template</a></h3>
<p>When using the Rust standard library (<code>std</code>) you can use the <a href="https://github.com/esp-rs/esp-idf-template">esp-idf-template</a> template, which will look something like:</p>
<pre><code class="language-shell">$ cargo generate --git https://github.com/esp-rs/esp-idf-template cargo
🤷   Project Name : esp-rust-app
🔧   Generating template ...
✔ 🤷   Rust toolchain (beware: nightly works only for esp32c3!) · esp
✔ 🤷   STD support · true
✔ 🤷   ESP-IDF native build version (stable = 4.3.1, upcoming = 4.4, master = 5.0; applicable only with `cargo build --features native`) · stable
✔ 🤷   MCU · esp32
[1/9]   Done: .cargo/config.toml
[2/9]   Done: .cargo
[3/9]   Done: .gitignore
[4/9]   Done: Cargo.toml
[5/9]   Done: build.rs
[6/9]   Done: rust-toolchain.toml
[7/9]   Done: sdkconfig.defaults
[8/9]   Done: src/main.rs
[9/9]   Done: src
🔧   Moving generated files into: `/Users/alice/esp-rust-app`...
✨   Done! New project created /Users/alice/esp-rust-app
</code></pre>
<h3 id="esp-template"><a class="header" href="#esp-template">esp-template</a></h3>
<p>For bare-metal applications (<code>no_std</code>) you can instead use the <a href="https://github.com/esp-rs/esp-template">esp-template</a> template:</p>
<pre><code class="language-shell">$ cargo generate --git https://github.com/esp-rs/esp-template
🤷   Project Name : esp-rust-app
🔧   Generating template ...
✔ 🤷   Which MCU to target? · esp32c3
✔ 🤷   Configure project to use Dev Containers (VS Code, GitHub Codespaces and Gitpod)? · true
[ 1/25]   Done: .cargo/config.toml
[ 2/25]   Done: .cargo
[ 3/25]   Done: .devcontainer/Dockerfile
[ 4/25]   Done: .devcontainer/devcontainer.json
[ 5/25]   Done: .devcontainer
[ 6/25]   Done: .dockerignore
[ 7/25]   Done: .gitdpod.Dockerfile
[ 8/25]   Done: .gitdpod.yml
[ 9/25]   Done: .gitignore
[10/25]   Done: .vscode/launch.json
[11/25]   Done: .vscode/settings.json
[12/25]   Done: .vscode/tasks.json
[13/25]   Done: .vscode
[14/25]   Done: Cargo.toml
[15/25]   Done: LICENSE-APACHE
[16/25]   Done: LICENSE-MIT
[17/25]   Done: docs/README.md
[18/25]   Done: docs
[19/25]   Done: rust-toolchain.toml
[20/25]   Done: scripts/build.sh
[21/25]   Done: scripts/flash.sh
[22/25]   Done: scripts/run-wokwi.sh
[23/25]   Done: scripts
[24/25]   Done: src/main.rs
[25/25]   Done: src
🔧   Moving generated files into: `/Users/alice/esp-rust-app`...
✨   Done! New project created /Users/alice/esp-rust-app
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>See the <a href="https://github.com/ivmarkov/rust-esp32-std-demo/">rust-esp32-std-demo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-glossary"><a class="header" href="#appendix-a-glossary">Appendix A: Glossary</a></h1>
<p>A number of acronyms are used in the embedded development space. This glossary attempts to define any acronyms used in this book.</p>
<h2 id="svd"><a class="header" href="#svd">SVD</a></h2>
<p><strong>S</strong>ystem <strong>V</strong>iew <strong>D</strong>escription.</p>
<p>The <a href="https://arm-software.github.io/CMSIS_5/SVD/html/index.html">CMSIS-SVD</a> specification formalizes the description of the system contained within a microcontroller. This specification was designed with ARM Cortex-M microcontrollers in mind, however it is still applicable to other architectures.</p>
<p>SVD files are XML and contain definitions for peripherals which can be consumed by tools such a <a href="https://github.com/rust-embedded/svd2rust/">svd2rust</a> to generate Peripheral Access Crates.</p>
<h2 id="pac"><a class="header" href="#pac">PAC</a></h2>
<p><strong>P</strong>eripheral <strong>A</strong>ccess <strong>C</strong>rate.</p>
<p>Provides a type-safe, low-level API for interacting with the device's hardware peripherals. For more information on the generated API please refer to the <a href="https://github.com/rust-embedded/svd2rust/">svd2rust</a> documentation.</p>
<h2 id="hal"><a class="header" href="#hal">HAL</a></h2>
<p><strong>H</strong>ardware <strong>A</strong>bstraction <strong>L</strong>ayer.</p>
<p>Provides higher-level abstractions over hardware peripherals which are more easily used by developers. These libraries are generally implemented on top of Peripheral Access Crates, and often implement the various traits provided by <a href="https://github.com/rust-embedded/embedded-hal">embedded-hal</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/mermaid.min.js"></script>
        <script type="text/javascript" src="assets/mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
